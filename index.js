// Carrega vari√°veis de ambiente do arquivo .env (apenas em ambiente local)
if (!process.env.DOCKER_ENV) {
    try {
        require('dotenv').config();
    } catch (err) {
        console.log('dotenv n√£o encontrado, usando vari√°veis de ambiente do sistema');
    }
}

// Utilit√°rio de email
const { emailConfig, enviarEmail } = require('./emailUtil');

// Classe para gerenciar configura√ß√£o e notifica√ß√µes por usu√°rio
class BotHandler {
    constructor() {
        this.configState = new Map(); // chave: userId, valor: { modoConfig: bool }
        this.emailPorUsuario = new Map(); // chave: userId, valor: email
    }

    getUserId(message) {
        return message.author || message.from;
    }

    isConfigMode(userId) {
        const state = this.configState.get(userId);
        return state && (state.modoConfig === true || state.modoConfig === 'aguardandoEmail');
    }

    setConfigMode(userId, value) {
        this.configState.set(userId, { modoConfig: value });
    }

    getEmail(userId) {
        // Sempre retorna o email padr√£o, mas permite configura√ß√£o personalizada se existir
        return this.emailPorUsuario.get(userId) || 'samal@cs-consoft.com.br';
    }

    setEmail(userId, email) {
        this.emailPorUsuario.set(userId, email);
    }

    async handleConfig(message, chat, userId) {
        const texto = message.body.trim();
        const state = this.configState.get(userId);
        if (texto === '1') {
            this.setConfigMode(userId, 'aguardandoEmail');
            await chat.sendMessage('Digite o novo email para receber notifica√ß√µes:');
            return true;
        }
        if (texto === '2') {
            this.setConfigMode(userId, false);
            await chat.sendMessage('Saindo do modo de configura√ß√£o. Bot voltando ao modo normal.');
            return true;
        }
        if (state.modoConfig === 'aguardandoEmail') {
            if (/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(texto)) {
                this.setEmail(userId, texto);
                this.setConfigMode(userId, false);
                await chat.sendMessage(`Email atualizado para: ${texto}\nSaindo do modo de configura√ß√£o.`);
            } else {
                await chat.sendMessage('Email inv√°lido. Tente novamente ou envie 2 para sair.');
            }
            return true;
        }
        await chat.sendMessage('Op√ß√£o inv√°lida.\n1 - Definir email\n2 - Sair');
        return true;
    }

    async startConfig(message, chat, userId) {
        this.setConfigMode(userId, true);
        const emailPersonalizado = this.emailPorUsuario.get(userId);
        const emailAtual = this.getEmail(userId);
        const isDefault = !emailPersonalizado;
        const status = isDefault ? '(padr√£o do sistema)' : '(personalizado)';
        await chat.sendMessage(`Email atual: ${emailAtual} ${status}\nEscolha uma op√ß√£o:\n1 - Definir email personalizado\n2 - Sair`);
    }

    async handleMedia(message, chat, userId) {
        let tipo = message.type === 'image' ? 'IMAGEM' : 'PDF';
        console.log(`[${chat.name || chat.id.user}] ${message.author || message.from}: Enviou uma ${tipo}.`);

        // Captura o texto/legenda da mensagem
        const textoMensagem = message.body ? message.body.trim() : '';
        console.log(`[DEBUG] Texto da mensagem: "${textoMensagem}"`);

        const emailDestino = this.getEmail(userId); // Usa a fun√ß√£o getEmail que j√° tem o email padr√£o
        console.log(`[DEBUG] Processando ${tipo} para envio para: ${emailDestino}`);

        try {
            // Baixa o arquivo da mensagem
            console.log(`[DEBUG] Tentando baixar m√≠dia...`);
            const media = await message.downloadMedia();
            if (!media) {
                console.log(`[ERRO] N√£o foi poss√≠vel baixar m√≠dia`);
                await chat.sendMessage('N√£o foi poss√≠vel baixar o arquivo para enviar por email.');
                return;
            }
            console.log(`[DEBUG] M√≠dia baixada com sucesso. MimeType: ${media.mimetype}`);

            // Prepara o anexo
            const attachment = {
                filename: tipo === 'IMAGEM' ? 'imagem.jpg' : 'documento.pdf',
                content: Buffer.from(media.data, 'base64'),
                contentType: media.mimetype
            };

            // Define o t√≠tulo do email baseado no texto da mensagem
            let tituloEmail;
            let corpoEmail;

            if (textoMensagem) {
                tituloEmail = textoMensagem;
                corpoEmail = `Voc√™ recebeu uma ${tipo} de ${message.author || message.from} no chat ${chat.name || chat.id.user}.\n\nTexto da mensagem: ${textoMensagem}`;
            } else {
                tituloEmail = `Nova mensagem (${tipo}) no chat ${chat.name || chat.id.user}`;
                corpoEmail = `Voc√™ recebeu uma ${tipo} de ${message.author || message.from} no chat ${chat.name || chat.id.user}.`;
            }

            console.log(`[DEBUG] T√≠tulo do email: "${tituloEmail}"`);
            console.log(`[DEBUG] Enviando email para: ${emailDestino}`);

            await enviarEmail(
                emailDestino,
                tituloEmail,
                corpoEmail,
                attachment
            );
            console.log(`[DEBUG] Email enviado com sucesso!`);

            const isDefault = !this.emailPorUsuario.get(userId);
            const status = isDefault ? ' (email padr√£o)' : ' (email personalizado)';
            const mensagemConfirmacao = textoMensagem
                ? `‚úÖ ${tipo} enviada para: ${emailDestino}${status}\nüìß T√≠tulo: "${textoMensagem}"`
                : `‚úÖ ${tipo} enviada para: ${emailDestino}${status}`;

            await chat.sendMessage(mensagemConfirmacao);
        } catch (e) {
            console.error(`[ERRO] Erro ao processar m√≠dia:`, e);
            await chat.sendMessage(`Erro ao enviar email: ${e.message}`);
        }
    }

    async handleDocument(message, chat) {
        await chat.sendMessage(`[${chat.name || chat.id.user}] ${message.author || message.from}: Enviou um DOCUMENTO (${message._data.mimetype}).`);
    }

    async handleInstrucao(chat) {
        await chat.sendMessage('ü§ñ *Bot WhatsApp Ativo*\n\nüìß *Email padr√£o configurado:* samal@cs-consoft.com.br\n\nüìã *Como usar:*\n‚Ä¢ Envie uma *imagem* ou *PDF* para receber por email\n‚Ä¢ Adicione um *texto junto com a imagem* para usar como t√≠tulo do email\n‚Ä¢ Digite *#CONFIG* para configurar email personalizado\n\n‚úÖ Pronto para receber seus arquivos!');
    }
}

const botHandler = new BotHandler();

// Importa as classes necess√°rias do whatsapp-web.js e libs para QR Code
const { Client, LocalAuth, RemoteAuth, NoAuth } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const { log } = require('console');
const path = require('path');
const fs = require('fs');



// Detecta se est√° rodando no Docker
function isRunningInDocker() {
    try {
        return fs.existsSync('/.dockerenv') ||
            fs.readFileSync('/proc/1/cgroup', 'utf8').includes('docker') ||
            process.env.DOCKER_ENV === 'true';
    } catch (err) {
        return false;
    }
}

const IS_DOCKER = isRunningInDocker();
console.log(`Executando em: ${IS_DOCKER ? 'Docker' : 'Local'}`);

// Detectar ambiente Render
function isRenderEnvironment() {
    return process.env.RENDER === 'true' || 
           process.env.NODE_ENV === 'production' || 
           process.env.PORT || 
           process.env.RENDER_SERVICE_ID;
}

// Limpar vari√°veis de ambiente problem√°ticas no Render
if (isRenderEnvironment()) {
    console.log('üåê Limpando vari√°veis de ambiente problem√°ticas...');
    delete process.env.PUPPETEER_EXECUTABLE_PATH;
    delete process.env.CHROME_BIN;
    delete process.env.GOOGLE_CHROME_BIN;
    process.env.PUPPETEER_SKIP_CHROMIUM_DOWNLOAD = 'false';
}

// Configura√ß√µes baseadas no ambiente (apenas Puppeteer, sem authDataPath)
const getConfig = () => {
    const isRender = isRenderEnvironment();
    
    if (isRender) {
        console.log('üåê Ambiente Render detectado - usando configura√ß√£o para produ√ß√£o');
        return {
            puppeteer: {
                headless: true,
                // N√£o especificar executablePath - deixar Puppeteer escolher
                args: [
                    '--no-sandbox',
                    '--disable-setuid-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-gpu',
                    '--disable-extensions',
                    '--no-first-run',
                    '--disable-default-apps',
                    '--disable-translate',
                    '--disable-sync',
                    '--hide-scrollbars',
                    '--mute-audio',
                    '--disable-background-timer-throttling',
                    '--disable-backgrounding-occluded-windows',
                    '--disable-renderer-backgrounding',
                    '--disable-ipc-flooding-protection'
                ],
                timeout: 60000,
                ignoreDefaultArgs: false
            }
        };
    } else if (IS_DOCKER) {
        console.log('üê≥ Ambiente Docker detectado');
        return {
            puppeteer: {
                headless: true,
                executablePath: '/usr/bin/chromium',
                args: [
                    '--no-sandbox',
                    '--disable-setuid-sandbox',
                    '--disable-dev-shm-usage',
                    '--disable-gpu',
                    '--disable-extensions',
                    '--disable-background-networking',
                    '--disable-sync',
                    '--mute-audio',
                    '--disable-ipc-flooding-protection',
                    '--window-size=1920,1080',
                    '--disable-web-security',
                    '--disable-features=VizDisplayCompositor',
                    '--no-first-run',
                    '--no-default-browser-check'
                ],
                timeout: 60000
            }
        };
    } else {
        console.log('üíª Ambiente local detectado');
        return {};
    }
};

const config = getConfig();

// Fun√ß√£o para configurar autentica√ß√£o persistente
function getAuthStrategy() {
    const isRender = isRenderEnvironment();
    
    // Verificar se existe sess√£o pr√©-configurada
    const preConfiguredSession = checkPreConfiguredSession();
    
    if (preConfiguredSession) {
        console.log('üîë Usando sess√£o pr√©-configurada - ZERO QR Code necess√°rio!');
        return preConfiguredSession;
    }
    
    if (isRender && process.env.MONGODB_URI) {
        // Render com MongoDB - Autentica√ß√£o remota persistente
        console.log('üîê Configurando autentica√ß√£o REMOTA (MongoDB)');
        try {
            const { MongoStore } = require('wwebjs-mongo');
            const mongoose = require('mongoose');
            
            mongoose.connect(process.env.MONGODB_URI);
            const store = new MongoStore({ mongoose: mongoose });
            
            return new RemoteAuth({
                store: store,
                backupSyncIntervalMs: 300000,
                clientId: "whatsapp-bot-csconsoft"
            });
        } catch (error) {
            console.log('‚ùå Erro ao configurar MongoDB, usando LocalAuth como fallback');
            return getLocalAuth();
        }
    } else {
        // Local/Docker/Render sem MongoDB - Autentica√ß√£o local persistente
        return getLocalAuth();
    }
}

// Verificar se existe sess√£o pr√©-configurada
function checkPreConfiguredSession() {
    try {
        // Verificar se existe arquivo de sess√£o pr√©-configurado
        const preSessionPath = './pre-configured-session';
        const authPath = './wwebjs_auth';
        
        if (fs.existsSync(preSessionPath)) {
            console.log('üìÅ Sess√£o pr√©-configurada encontrada!');
            
            // Copiar sess√£o pr√©-configurada para o local correto
            if (!fs.existsSync(authPath)) {
                fs.mkdirSync(authPath, { recursive: true });
            }
            
            // Copiar todos os arquivos da sess√£o
            const files = fs.readdirSync(preSessionPath);
            files.forEach(file => {
                const srcPath = path.join(preSessionPath, file);
                const destPath = path.join(authPath, file);
                
                if (fs.statSync(srcPath).isDirectory()) {
                    copyDirectory(srcPath, destPath);
                } else {
                    fs.copyFileSync(srcPath, destPath);
                }
            });
            
            console.log('‚úÖ Sess√£o pr√©-configurada copiada com sucesso!');
            return new LocalAuth({
                clientId: "whatsapp-bot-csconsoft",
                dataPath: authPath
            });
        }
        
        // Verificar vari√°vel de ambiente com sess√£o codificada
        if (process.env.WHATSAPP_SESSION_DATA) {
            console.log('üîë Restaurando sess√£o de vari√°vel de ambiente...');
            return restoreSessionFromEnv();
        }
        
        return null;
    } catch (error) {
        console.log('‚ùå Erro ao verificar sess√£o pr√©-configurada:', error.message);
        return null;
    }
}

// Fun√ß√£o para copiar diret√≥rio recursivamente
function copyDirectory(src, dest) {
    if (!fs.existsSync(dest)) {
        fs.mkdirSync(dest, { recursive: true });
    }
    
    const files = fs.readdirSync(src);
    files.forEach(file => {
        const srcPath = path.join(src, file);
        const destPath = path.join(dest, file);
        
        if (fs.statSync(srcPath).isDirectory()) {
            copyDirectory(srcPath, destPath);
        } else {
            fs.copyFileSync(srcPath, destPath);
        }
    });
}

// Restaurar sess√£o de vari√°vel de ambiente
function restoreSessionFromEnv() {
    try {
        const sessionData = JSON.parse(Buffer.from(process.env.WHATSAPP_SESSION_DATA, 'base64').toString());
        const authPath = './wwebjs_auth';
        
        if (!fs.existsSync(authPath)) {
            fs.mkdirSync(authPath, { recursive: true });
        }
        
        // Escrever dados da sess√£o
        Object.keys(sessionData).forEach(fileName => {
            const filePath = path.join(authPath, fileName);
            const dirPath = path.dirname(filePath);
            
            if (!fs.existsSync(dirPath)) {
                fs.mkdirSync(dirPath, { recursive: true });
            }
            
            fs.writeFileSync(filePath, sessionData[fileName]);
        });
        
        console.log('‚úÖ Sess√£o restaurada de vari√°vel de ambiente!');
        return new LocalAuth({
            clientId: "whatsapp-bot-csconsoft",
            dataPath: authPath
        });
    } catch (error) {
        console.log('‚ùå Erro ao restaurar sess√£o de vari√°vel de ambiente:', error.message);
        return null;
    }
}

function getLocalAuth() {
    console.log('üîê Configurando autentica√ß√£o LOCAL (persistente)');
    
    // Usar n√∫mero de telefone como identificador da sess√£o
    const phoneNumber = process.env.WHATSAPP_PHONE || process.env.PHONE_NUMBER || "default";
    const sessionName = `whatsapp-bot-${phoneNumber}`;
    const authPath = `./sessions/${sessionName}`;
    
    // Garantir que o diret√≥rio existe
    if (!fs.existsSync(authPath)) {
        fs.mkdirSync(authPath, { recursive: true });
        console.log(`üìÅ Criado diret√≥rio de autentica√ß√£o: ${authPath}`);
    }
    
    console.log(`üì± Sess√£o configurada para: ${phoneNumber}`);
    
    return new LocalAuth({
        clientId: sessionName,
        dataPath: authPath
    });
}

// Configurar estrat√©gia de autentica√ß√£o
const authStrategy = getAuthStrategy();

// Autentica√ß√£o persistente configurada - QR Code apenas na primeira vez
console.log('‚úÖ Modo de autentica√ß√£o PERSISTENTE ativado');
console.log('üì± QR Code necess√°rio APENAS na primeira execu√ß√£o');
console.log('üîÑ Execu√ß√µes seguintes conectar√£o automaticamente');

let ultimoQR = null; // Armazena o √∫ltimo QR gerado
let qrMostrado = false; // Controla se o QR j√° foi exibido
let qrGerado = false; // Nova vari√°vel para controlar se j√° foi gerado
let sessaoExiste = false; // Verifica se j√° existe sess√£o salva

// Verificar se j√° existe sess√£o salva
function verificarSessaoExistente() {
    try {
        const authPath = './wwebjs_auth';
        if (fs.existsSync(authPath)) {
            const files = fs.readdirSync(authPath);
            sessaoExiste = files.length > 0;
            
            if (sessaoExiste) {
                console.log('‚úÖ Sess√£o existente encontrada - conectando automaticamente...');
                console.log('üö´ QR Code N√ÉO ser√° necess√°rio!');
            } else {
                console.log('‚ö†Ô∏è  Primeira execu√ß√£o - QR Code ser√° necess√°rio UMA vez');
            }
        }
    } catch (error) {
        console.log('üîç Verificando sess√£o pela primeira vez...');
        sessaoExiste = false;
    }
    
    return sessaoExiste;
}

// Verificar sess√£o existente
verificarSessaoExistente();

// Fun√ß√£o para exportar dados da sess√£o
function exportSessionData() {
    try {
        const authPath = './wwebjs_auth';
        if (!fs.existsSync(authPath)) {
            console.log('‚ùå Nenhuma sess√£o encontrada para exportar');
            return;
        }
        
        const sessionData = {};
        
        function readDirectory(dirPath, basePath = '') {
            const files = fs.readdirSync(dirPath);
            
            files.forEach(file => {
                const fullPath = path.join(dirPath, file);
                const relativePath = basePath ? path.join(basePath, file) : file;
                
                if (fs.statSync(fullPath).isDirectory()) {
                    readDirectory(fullPath, relativePath);
                } else {
                    sessionData[relativePath] = fs.readFileSync(fullPath);
                }
            });
        }
        
        readDirectory(authPath);
        
        // Converter para base64 para facilitar transporte
        const sessionBase64 = Buffer.from(JSON.stringify(sessionData)).toString('base64');
        
        // Salvar em arquivo
        fs.writeFileSync('./session-export.txt', sessionBase64);
        
        console.log('‚úÖ Sess√£o exportada para: ./session-export.txt');
        console.log('üîë Use este arquivo para configurar WHATSAPP_SESSION_DATA');
        console.log('üìã Conte√∫do do arquivo pode ser usado como vari√°vel de ambiente');
        
    } catch (error) {
        console.log('‚ùå Erro ao exportar sess√£o:', error.message);
    }
}

// Nome exato do grupo que ser√° monitorado
const NOME_GRUPO = "GRUPO_X"; // Altere para o nome real do seu grupo

// Fun√ß√£o para criar o cliente com tratamento de erro
function createClient() {
    try {
        console.log('üîß Configura√ß√µes do cliente:', JSON.stringify(config, null, 2));
        
        // Log para debug no Render
        if (isRenderEnvironment()) {
            console.log('üêû Debug Render:');
            console.log(`   - PUPPETEER_EXECUTABLE_PATH: ${process.env.PUPPETEER_EXECUTABLE_PATH || 'undefined'}`);
            console.log(`   - PUPPETEER_SKIP_CHROMIUM_DOWNLOAD: ${process.env.PUPPETEER_SKIP_CHROMIUM_DOWNLOAD}`);
            console.log(`   - NODE_ENV: ${process.env.NODE_ENV}`);
            console.log(`   - RENDER: ${process.env.RENDER}`);
        }

        const client = new Client({
            authStrategy: authStrategy,
            ...config
        });

        // Adicionar listeners para debug
        if (IS_DOCKER) {
            client.on('disconnected', (reason) => {
                console.log('üîå Cliente desconectado:', reason);
            });

            client.on('auth_failure', (msg) => {
                console.log('‚ùå Falha na autentica√ß√£o:', msg);
            });

            client.on('loading_screen', (percent, message) => {
                console.log(`üîÑ Carregando: ${percent}% - ${message}`);
            });

            client.on('authenticated', () => {
                console.log('‚úÖ Autenticado com sucesso!');
            });

            client.on('auth_failure', msg => {
                console.log('‚ùå Falha na autentica√ß√£o:', msg);
            });

            client.on('disconnected', (reason) => {
                console.log('üîå Desconectado:', reason);
            });
        }

        return client;
    } catch (error) {
        console.error('‚ùå Erro ao criar cliente WhatsApp:', error.message);
        console.error('üîç Stack completo:', error.stack);

        if (IS_DOCKER) {
            console.log('üê≥ Tentando configura√ß√£o alternativa para Docker...');

            // Configura√ß√£o mais minimalista
            const fallbackClient = new Client({
                authStrategy: authStrategy,
                puppeteer: {
                    headless: true,
                    args: [
                        '--no-sandbox',
                        '--disable-setuid-sandbox',
                        '--disable-dev-shm-usage',
                        '--disable-gpu',
                        '--single-process'
                    ],
                    executablePath: '/usr/bin/chromium-browser',
                    timeout: 30000
                }
            });

            return fallbackClient;
        }

        throw error;
    }
}

// Cria o cliente do WhatsApp
console.log('üöÄ Criando cliente WhatsApp...');
const client = createClient();
console.log('‚úÖ Cliente WhatsApp criado com sucesso!');
console.log('‚è≥ Aguardando autentica√ß√£o ou QR Code...');

// Criar servidor HTTP para health check (para Render)
const http = require('http');
const server = http.createServer((req, res) => {
    if (req.url === '/health') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ 
            status: 'ok', 
            timestamp: new Date().toISOString(),
            bot_connected: client && client.info ? true : false
        }));
    } else {
        res.writeHead(404, { 'Content-Type': 'text/plain' });
        res.end('Not Found');
    }
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
    console.log(`üåê Health check server rodando na porta ${PORT}`);
});

// Tratamento de erros n√£o capturados com categoriza√ß√£o
process.on('unhandledRejection', (reason, promise) => {
    const errorMsg = reason?.message || reason;

    // Erros espec√≠ficos que podemos ignorar com seguran√ßa
    const ignorePatterns = [
        'Protocol error (Network.setUserAgentOverride): Session closed',
        'Protocol error (Runtime.callFunctionOn): Session closed',
        'Protocol error (Page.navigate): Session closed',
        'Target closed',
        'Session closed'
    ];

    const shouldIgnore = ignorePatterns.some(pattern =>
        String(errorMsg).includes(pattern)
    );

    if (shouldIgnore) {
        console.log('üîá Erro de protocolo ignorado:', errorMsg);
        return;
    }

    // Erros cr√≠ticos que requerem aten√ß√£o
    const criticalPatterns = [
        'EBUSY',
        'ENOENT',
        'Permission denied',
        'Cannot read properties'
    ];

    const isCritical = criticalPatterns.some(pattern =>
        String(errorMsg).includes(pattern)
    );

    if (isCritical) {
        console.error('‚ùå ERRO CR√çTICO (Unhandled Rejection):', errorMsg);
        console.error('üìç Promise:', promise);
        console.error('üîç Stack:', reason?.stack);
    } else {
        console.log('‚ö†Ô∏è  Unhandled Rejection (n√£o cr√≠tico):', errorMsg);
    }
});

process.on('uncaughtException', (error) => {
    const errorMsg = error?.message || error;

    // Erros espec√≠ficos que podemos ignorar
    const ignorePatterns = [
        'Protocol error',
        'Session closed',
        'Target closed'
    ];

    const shouldIgnore = ignorePatterns.some(pattern =>
        String(errorMsg).includes(pattern)
    );

    if (shouldIgnore) {
        console.log('üîá Exce√ß√£o de protocolo ignorada:', errorMsg);
        return;
    }

    console.error('‚ùå EXCE√á√ÉO N√ÉO CAPTURADA:', errorMsg);
    console.error('üîç Stack:', error?.stack);

    // Em ambiente Docker, reiniciar pode ser mais seguro
    if (IS_DOCKER) {
        console.error('üê≥ Executando em Docker - considerando reinicializa√ß√£o...');
        // N√£o finalizar imediatamente, permitir que o container seja reiniciado externamente
        setTimeout(() => {
            console.error('üíÄ Finalizando processo ap√≥s erro cr√≠tico...');
            process.exit(1);
        }, 5000);
    } else {
        console.log('üíª Executando localmente - continuando execu√ß√£o...');
    }
});

// Evento disparado quando o QR Code deve ser exibido no terminal
client.on('qr', qr => {
    if (sessaoExiste) {
        console.log("‚ö†Ô∏è QR Code solicitado mesmo com sess√£o existente - pode haver problema na sess√£o");
        console.log("ÔøΩÔ∏è Limpando sess√£o corrompida...");
        
        // Limpar sess√£o corrompida
        try {
            const authPath = './wwebjs_auth';
            if (fs.existsSync(authPath)) {
                fs.rmSync(authPath, { recursive: true, force: true });
                console.log("‚úÖ Sess√£o corrompida removida");
            }
        } catch (error) {
            console.log("‚ùå Erro ao limpar sess√£o:", error.message);
        }
    }

    console.log("üì± PRIMEIRA EXECU√á√ÉO - QR Code necess√°rio para configura√ß√£o inicial");
    console.log("üîÑ Ap√≥s escanear, o bot lembrar√° da sess√£o PERMANENTEMENTE");

    qrGerado = true;
    qrMostrado = true;
    ultimoQR = qr;

    // Gera o QR no terminal
    qrcode.generate(qr, { small: true });
    console.log("üì± QR Code gerado! Escaneie com o WhatsApp (Aparelhos conectados).");
    console.log("üéØ IMPORTANTE: Ap√≥s escanear, QR Code NUNCA mais ser√° necess√°rio!");
    console.log("‚è∞ O QR Code expira em alguns minutos, se n√£o funcionar, reinicie o bot.");
});

// Evento disparado quando a autentica√ß√£o √© bem-sucedida
client.on('authenticated', () => {
    console.log('üîê Autentica√ß√£o realizada com sucesso!');
    console.log('üíæ Sess√£o ser√° salva para pr√≥ximas execu√ß√µes');
    console.log('üö´ QR Code n√£o ser√° mais necess√°rio!');
});

// Evento disparado em caso de falha na autentica√ß√£o
client.on('auth_failure', msg => {
    console.log('‚ùå Falha na autentica√ß√£o:', msg);
    console.log('üóëÔ∏è Limpando poss√≠vel sess√£o corrompida...');
    
    try {
        const authPath = './wwebjs_auth';
        if (fs.existsSync(authPath)) {
            fs.rmSync(authPath, { recursive: true, force: true });
            console.log("‚úÖ Sess√£o corrompida removida - reinicie o bot");
        }
    } catch (error) {
        console.log("‚ùå Erro ao limpar sess√£o:", error.message);
    }
});



// Evento disparado quando o bot est√° pronto para uso
client.on('ready', async () => {
    console.log('‚úÖ Bot do WhatsApp est√° pronto e funcionando!');
    console.log('üì± Conectado como:', client.info.wid.user);
    console.log('üìû Nome:', client.info.pushname);
    console.log('ÔøΩ SESS√ÉO SALVA - Pr√≥ximas execu√ß√µes conectar√£o automaticamente!');
    console.log('üö´ QR Code NUNCA mais ser√° necess√°rio (at√© logout manual)');
    console.log('ÔøΩüí¨ Pronto para receber mensagens PRIVADAS!');
    console.log('üìß Email padr√£o configurado: samal@cs-consoft.com.br');
    console.log('');
    console.log('üìã Como usar:');
    console.log('   ‚Ä¢ Envie uma imagem ou PDF em conversa privada');
    console.log('   ‚Ä¢ Adicione texto junto com a imagem para usar como t√≠tulo');
    console.log('   ‚Ä¢ Digite #CONFIG para configurar email personalizado');
    console.log('');
    console.log('üîÑ Aguardando mensagens...');
    
    // Marcar que a sess√£o foi estabelecida com sucesso
    sessaoExiste = true;
    
    // Exportar sess√£o para backup (se solicitado)
    if (process.env.EXPORT_SESSION === 'true') {
        setTimeout(() => {
            exportSessionData();
        }, 5000);
    }
    
    // Testar se consegue receber eventos
    setTimeout(() => {
        console.log('‚è∞ Bot ativo h√° 10 segundos - teste enviando uma mensagem!');
    }, 10000);
});

// Evento disparado para cada mensagem recebida
client.on('message', async message => {
    console.log('üîî MENSAGEM RECEBIDA!');
    console.log(`üì± De ID: ${message.from}`);
    console.log(`üí¨ Conte√∫do: "${message.body}"`);
    console.log(`üìã Tipo: ${message.type}`);
    console.log(`‚è∞ Timestamp: ${new Date(message.timestamp * 1000)}`);
    
    try {
        const chat = await message.getChat();
        console.log(`üìÅ Chat - Tipo: ${chat.isGroup ? 'GRUPO' : 'PRIVADO'}`);
        
        // ‚ùå IGNORAR MENSAGENS DE GRUPO
        if (chat.isGroup) {
            console.log(`‚è≠Ô∏è IGNORANDO mensagem de grupo: "${chat.name}"`);
            console.log(`üí¨ Bot funciona APENAS em conversas privadas!`);
            return;
        }

        console.log(`‚úÖ Processando mensagem privada...`);

        const userId = botHandler.getUserId(message);
        console.log(`üë§ User ID: ${userId}`);

        // Verificar se √© comando de configura√ß√£o
        if (message.body.toUpperCase() === '#CONFIG') {
            console.log('‚öôÔ∏è Comando #CONFIG detectado');
            await botHandler.startConfig(message, chat, userId);
            return;
        }

        // Se estiver em modo config
        if (botHandler.isConfigMode(userId)) {
            console.log('üìß Processando configura√ß√£o...');
            await botHandler.handleConfig(message, chat, userId);
            return;
        }

        // Verificar se tem m√≠dia
        if (message.hasMedia) {
            console.log('üìé Mensagem com m√≠dia detectada!');
            console.log(`üìã Tipo de m√≠dia: ${message.type}`);
            
            const media = await message.downloadMedia();
            console.log(`üìä M√≠dia baixada - Tipo: ${media.mimetype}, Tamanho: ${media.data.length} bytes`);
            
            if (media.mimetype.startsWith('image/') || media.mimetype === 'application/pdf') {
                console.log('‚úÖ Tipo de arquivo aceito, processando...');
                await botHandler.handleMedia(message, chat, userId);
            } else {
                console.log(`‚ùå Tipo de arquivo n√£o suportado: ${media.mimetype}`);
                await message.reply('‚ùå Apenas imagens (JPG, PNG) e PDFs s√£o aceitos.');
            }
        } else {
            console.log('üí¨ Mensagem sem m√≠dia (apenas texto)');
            
            // Responder com instru√ß√µes se for apenas texto
            if (message.body.toLowerCase().includes('help') || 
                message.body.toLowerCase().includes('ajuda') || 
                message.body === '?') {
                await botHandler.handleInstrucao(chat);
            }
        }

    } catch (error) {
        console.error('‚ùå Erro ao processar mensagem:', error);
        console.error('üìä Stack trace:', error.stack);
        
        try {
            await message.reply('‚ùå Ocorreu um erro ao processar sua mensagem. Tente novamente.');
        } catch (replyError) {
            console.error('‚ùå Erro ao enviar resposta de erro:', replyError);
        }
    }
});


// Adicionar mais listeners para debug
client.on('message_create', async message => {
    console.log('üÜï message_create disparado');
});

client.on('message_revoke_everyone', async (after, before) => {
    console.log('üóëÔ∏è Mensagem deletada para todos');
});

client.on('message_ack', (message, ack) => {
    console.log(`üì¨ ACK da mensagem: ${ack}`);
});

client.on('change_state', state => {
    console.log('üîÑ Estado mudou para:', state);
});

client.on('disconnected', (reason) => {
    console.log('üîå Cliente desconectado:', reason);
});

console.log('üîß Inicializando cliente WhatsApp...');
console.log('üí¨ Modo APENAS conversas privadas ativado');
console.log('üö´ Mensagens de grupo ser√£o ignoradas');
console.log('üíæ Autentica√ß√£o PERSISTENTE - QR Code apenas na primeira vez');

if (sessaoExiste) {
    console.log('üöÄ Conectando automaticamente com sess√£o salva...');
} else {
    console.log('‚ö†Ô∏è Primeira execu√ß√£o - QR Code ser√° solicitado UMA vez');
}

// Adicionar delay em ambiente Docker para estabilizar
if (IS_DOCKER) {
    console.log('üê≥ Aguardando 3 segundos para estabilizar ambiente Docker...');
    setTimeout(() => {
        console.log('üöÄ Iniciando cliente...');
        client.initialize();
    }, 3000);
} else {
    client.initialize();
}